# -*- coding: utf-8 -*-
"""FluidProj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nStR5tYXtPp8-_io6t6h_BTv6WoxMNux
"""

import cv2

def video_to_images(video_path, output_folder):

    video_capture = cv2.VideoCapture(video_path)

    import os
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    success, frame = video_capture.read()
    count = 0
    while success:

        image_path = os.path.join(output_folder, f"frame_{count}.jpg")
        cv2.imwrite(image_path, frame)


        success, frame = video_capture.read()
        count += 1


    video_capture.release()


video_path = '/content/drive/MyDrive/Fluid Proj/3CYL_Flow.mp4'
output_folder = '/content/drive/MyDrive/Fluid Proj/Imagestack2'

video_to_images(video_path, output_folder)

import os
import random
import matplotlib.pyplot as plt
from PIL import Image

def print_random_images(folder_path, num_images=5, image_width=200):
    files = os.listdir(folder_path)
    image_files = [f for f in files if f.endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp'))]
    if not image_files:
        print("No image files found in the folder.")
        return
    num_images = min(num_images, len(image_files))
    selected_indices = random.sample(range(len(image_files)), num_images)
    num_rows = (num_images + 4) // 5
    fig, axes = plt.subplots(num_rows, 5, figsize=(20, 4 * num_rows))
    axes = axes.flatten()
    for i, idx in enumerate(selected_indices):
        image_file = image_files[idx]
        try:
            img_path = os.path.join(folder_path, image_file)
            img = Image.open(img_path)
            wpercent = (image_width / float(img.size[0]))
            hsize = int((float(img.size[1]) * float(wpercent)))
            img = img.resize((image_width, hsize), Image.ANTIALIAS)
            axes[i].imshow(img)
            axes[i].axis('off')
            # axes[i].set_title(image_file)
        except Exception as e:
            print(f"Error displaying {image_file}: {e}")
    plt.tight_layout()
    plt.show()

folder_path = "/content/drive/MyDrive/Fluid Proj/Imagestack2"
num_images_to_print = 10
image_width = 200
print_random_images(folder_path, num_images_to_print, image_width)

from PIL import Image
import numpy as np
import os

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir(folder):
        img_path = os.path.join(folder, filename)
        if os.path.isfile(img_path):
            try:
                img = Image.open(img_path)
                img_gray = img.convert('L')
                img_array = np.array(img_gray)
                images.append(img_array)
            except:
                print(f"Failed to load image: {img_path}")
    return images

folder_path = "/content/drive/MyDrive/Fluid Proj/Imagestack2"
image_array = load_images_from_folder(folder_path)

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img.flatten())
    return np.array(images)

def compute_mean(images):
    return np.mean(images, axis=0)

def compute_fluctuation_matrix(images, mean_image):
    return images - mean_image

def perform_svd(fluctuation_matrix):
    U, S, Vt = np.linalg.svd(fluctuation_matrix, full_matrices=False)
    return U, S, Vt



images_folder = '/content/drive/MyDrive/Fluid Proj/Imagestack2'
output_folder = '/content/drive/MyDrive/Fluid Proj/SVD_output'
batch_size = 100
modes = 10

images = read_images(images_folder)

mean_image = compute_mean(images)

num_batches = len(images) // batch_size + 1
for batch_idx in range(num_batches):
    start_idx = batch_idx * batch_size
    end_idx = min((batch_idx + 1) * batch_size, len(images))
    batch_images = images[start_idx:end_idx]

    if len(batch_images) == 0:
        break

    fluctuation_matrix = compute_fluctuation_matrix(batch_images, mean_image)

    U, S, Vt = perform_svd(fluctuation_matrix)


print("Printing top 10 energy states modes completed!")

def reconstruct_images(U, S, Vt, modes):
    reconstructed_images  = U @ S @ Vt + compute_mean(images)
    return reconstructed_images

S_new = np.zeros((51,51))
    np.fill_diagonal(S_new, S)
    reconstructed_images = reconstruct_images(U, S_new, Vt, modes)

import numpy as np
import matplotlib.pyplot as plt

singular_values = S

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(singular_values) + 1), singular_values, marker='o', linestyle='-')
plt.title('Singular Values')
plt.xlabel('Mode')
plt.ylabel('Singular Value')
plt.grid(True)
plt.show()

cumulative_energy = np.cumsum(singular_values ** 2 / np.sum(singular_values ** 2))

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(cumulative_energy) + 1), cumulative_energy, marker='o', linestyle='-')
plt.title('Cumulative Energy Captured by Modes')
plt.xlabel('Number of Modes')
plt.ylabel('Cumulative Energy')
plt.grid(True)
plt.show()

top_modes_indices = np.argsort(singular_values)[::-1][:10]
top_modes_energy = singular_values

print("Top 10 energy states (modes):")
for mode, energy in zip(top_modes_indices, top_modes_energy):
    print(f"Mode {mode + 1}: Energy = {round(energy,4)}")

images[0].shape

reconstructed_images.shape

import matplotlib.pyplot as plt

# Plot the top 10 reconstructed images
plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(image_array[0].shape), cmap=None)
    plt.title(f"Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img)
    return images

def add_gaussian_noise(image, magnitude):
    mean = 0
    sigma = magnitude * np.max(image) / 5
    noise = np.random.normal(mean, sigma, image.shape)
    noisy_image = image + noise
    noisy_image = np.clip(noisy_image, 0, 255).astype(np.uint8)
    return noisy_image





images_folder = '/content/drive/MyDrive/Fluid Proj/Imagestack2'
output_folder = '/content/drive/MyDrive/Fluid Proj/Noisy_Images_Gaussian'

original_images = read_images(images_folder)

noise_magnitudes = [0.2, 0.4, 0.6, 0.8]
noise_types = ['Gaussian']

for noise_type in noise_types:
    for magnitude in noise_magnitudes:
        for idx, image in enumerate(original_images):
            if noise_type == 'Gaussian':
                noisy_image = add_gaussian_noise(image, magnitude)

            output_filename = f'{noise_type}_Noise_{int(magnitude*100)}_{idx+1}.png'
            cv2.imwrite(os.path.join(output_folder, output_filename), noisy_image)

print("Noise addition completed!")

from PIL import Image
import numpy as np
import os

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir(folder):
        img_path = os.path.join(folder, filename)
        if os.path.isfile(img_path):
            try:
                img = Image.open(img_path)
                img_gray = img.convert('L')
                img_array = np.array(img_gray)
                images.append(img_array)
            except:
                print(f"Failed to load image: {img_path}")
    return images

folder_path = "/content/drive/MyDrive/Fluid Proj/New_Noise_Gaussian_20"
image_array = load_images_from_folder(folder_path)

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img.flatten())
    return np.array(images)

def compute_mean(images):
    return np.mean(images, axis=0)

def compute_fluctuation_matrix(images, mean_image):
    return images - mean_image

def perform_svd(fluctuation_matrix):
    U, S, Vt = np.linalg.svd(fluctuation_matrix, full_matrices=False)
    return U, S, Vt



images_folder = '/content/drive/MyDrive/Fluid Proj/New_Noise_Gaussian_20'
batch_size = 100
modes = 10

images = read_images(images_folder)

mean_image = compute_mean(images)

num_batches = len(images) // batch_size + 1
for batch_idx in range(num_batches):
    start_idx = batch_idx * batch_size
    end_idx = min((batch_idx + 1) * batch_size, len(images))
    batch_images = images[start_idx:end_idx]

    if len(batch_images) == 0:
        break

    fluctuation_matrix = compute_fluctuation_matrix(batch_images, mean_image)

    U, S, Vt = perform_svd(fluctuation_matrix)


print("Applying Svd on Gaussian 20 % Noise completed!")

def reconstruct_images(U, S, Vt, modes):
    reconstructed_images  = U @ S @ Vt + compute_mean(images)
    return reconstructed_images

S_new = np.zeros((100,100))
np.fill_diagonal(S_new, S)
reconstructed_images = reconstruct_images(U, S_new, Vt, modes)

import numpy as np
import matplotlib.pyplot as plt

singular_values = S

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(singular_values) + 1), singular_values, marker='o', linestyle='-')
plt.title('Singular Values')
plt.xlabel('Mode')
plt.ylabel('Singular Value')
plt.grid(True)
plt.show()

cumulative_energy = np.cumsum(singular_values ** 2 / np.sum(singular_values ** 2))

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(cumulative_energy) + 1), cumulative_energy, marker='o', linestyle='-')
plt.title('Cumulative Energy Captured by Modes')
plt.xlabel('Number of Modes')
plt.ylabel('Cumulative Energy')
plt.grid(True)
plt.show()

top_modes_indices = np.argsort(singular_values)[::-1][:10]
top_modes_energy = singular_values

print("Top 10 energy states (modes):")
for mode, energy in zip(top_modes_indices, top_modes_energy):
    print(f"Mode {mode + 1}: Energy = {round(energy,4)}")

import matplotlib.pyplot as plt

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(image_array[0].shape), cmap=None)
    plt.title(f"Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

from PIL import Image
import numpy as np
import os

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir(folder):
        img_path = os.path.join(folder, filename)
        if os.path.isfile(img_path):
            try:
                img = Image.open(img_path)
                img_gray = img.convert('L')
                img_array = np.array(img_gray)
                images.append(img_array)
            except:
                print(f"Failed to load image: {img_path}")
    return images

folder_path = "/content/drive/MyDrive/Fluid Proj/New_Noise_Gaussian_40"
image_array = load_images_from_folder(folder_path)

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img.flatten())
    return np.array(images)

def compute_mean(images):
    return np.mean(images, axis=0)

def compute_fluctuation_matrix(images, mean_image):
    return images - mean_image

def perform_svd(fluctuation_matrix):
    U, S, Vt = np.linalg.svd(fluctuation_matrix, full_matrices=False)
    return U, S, Vt



images_folder = '/content/drive/MyDrive/Fluid Proj/New_Noise_Gaussian_40'

batch_size = 100
modes = 10

images = read_images(images_folder)

mean_image = compute_mean(images)

num_batches = len(images) // batch_size + 1
for batch_idx in range(num_batches):
    start_idx = batch_idx * batch_size
    end_idx = min((batch_idx + 1) * batch_size, len(images))
    batch_images = images[start_idx:end_idx]

    if len(batch_images) == 0:
        break

    fluctuation_matrix = compute_fluctuation_matrix(batch_images, mean_image)

    U, S, Vt = perform_svd(fluctuation_matrix)


print("Printing top 10 energy states modes completed!")

def reconstruct_images(U, S, Vt, modes):
    reconstructed_images  = U @ S @ Vt + compute_mean(images)
    return reconstructed_images

S_new = np.zeros((71,71))
np.fill_diagonal(S_new, S)
reconstructed_images = reconstruct_images(U, S_new, Vt, modes)

import numpy as np
import matplotlib.pyplot as plt

singular_values = S

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(singular_values) + 1), singular_values, marker='o', linestyle='-')
plt.title('Singular Values')
plt.xlabel('Mode')
plt.ylabel('Singular Value')
plt.grid(True)
plt.show()

cumulative_energy = np.cumsum(singular_values ** 2 / np.sum(singular_values ** 2))

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(cumulative_energy) + 1), cumulative_energy, marker='o', linestyle='-')
plt.title('Cumulative Energy Captured by Modes')
plt.xlabel('Number of Modes')
plt.ylabel('Cumulative Energy')
plt.grid(True)
plt.show()

top_modes_indices = np.argsort(singular_values)[::-1][:10]
top_modes_energy = singular_values

print("Top 10 energy states (modes):")
for mode, energy in zip(top_modes_indices, top_modes_energy):
    print(f"Mode {mode + 1}: Energy = {round(energy,4)}")

import matplotlib.pyplot as plt

# Plot the top 10 reconstructed images
plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(image_array[0].shape), cmap=None)
    plt.title(f"Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

from PIL import Image
import numpy as np
import os

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir(folder):
        img_path = os.path.join(folder, filename)
        if os.path.isfile(img_path):
            try:
                img = Image.open(img_path)
                img_gray = img.convert('L')
                img_array = np.array(img_gray)
                images.append(img_array)
            except:
                print(f"Failed to load image: {img_path}")
    return images

folder_path = "/content/drive/MyDrive/Fluid Proj/new_gaussian_60"
image_array = load_images_from_folder(folder_path)

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img.flatten())
    return np.array(images)

def compute_mean(images):
    return np.mean(images, axis=0)

def compute_fluctuation_matrix(images, mean_image):
    return images - mean_image

def perform_svd(fluctuation_matrix):
    U, S, Vt = np.linalg.svd(fluctuation_matrix, full_matrices=False)
    return U, S, Vt



images_folder = '/content/drive/MyDrive/Fluid Proj/new_gaussian_60'
batch_size = 100
modes = 10

images = read_images(images_folder)

mean_image = compute_mean(images)

num_batches = len(images) // batch_size + 1
for batch_idx in range(num_batches):
    start_idx = batch_idx * batch_size
    end_idx = min((batch_idx + 1) * batch_size, len(images))
    batch_images = images[start_idx:end_idx]

    if len(batch_images) == 0:
        break

    fluctuation_matrix = compute_fluctuation_matrix(batch_images, mean_image)

    U, S, Vt = perform_svd(fluctuation_matrix)


print("Printing top 10 energy states modes completed!")

def reconstruct_images(U, S, Vt, modes):
    reconstructed_images  = U @ S @ Vt + compute_mean(images)
    return reconstructed_images

S_new = np.zeros((100,100))
np.fill_diagonal(S_new, S)
reconstructed_images = reconstruct_images(U, S_new, Vt, modes)

import numpy as np
import matplotlib.pyplot as plt

singular_values = S

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(singular_values) + 1), singular_values, marker='o', linestyle='-')
plt.title('Singular Values')
plt.xlabel('Mode')
plt.ylabel('Singular Value')
plt.grid(True)
plt.show()

cumulative_energy = np.cumsum(singular_values ** 2 / np.sum(singular_values ** 2))

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(cumulative_energy) + 1), cumulative_energy, marker='o', linestyle='-')
plt.title('Cumulative Energy Captured by Modes')
plt.xlabel('Number of Modes')
plt.ylabel('Cumulative Energy')
plt.grid(True)
plt.show()

top_modes_indices = np.argsort(singular_values)[::-1][:10]
top_modes_energy = singular_values

print("Top 10 energy states (modes):")
for mode, energy in zip(top_modes_indices, top_modes_energy):
    print(f"Mode {mode + 1}: Energy = {round(energy,4)}")

import matplotlib.pyplot as plt

# Plot the top 10 reconstructed images
plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(image_array[0].shape), cmap=None)
    plt.title(f"Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

from PIL import Image
import numpy as np
import os

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir(folder):
        img_path = os.path.join(folder, filename)
        if os.path.isfile(img_path):
            try:
                img = Image.open(img_path)
                img_gray = img.convert('L')
                img_array = np.array(img_gray)
                images.append(img_array)
            except:
                print(f"Failed to load image: {img_path}")
    return images

folder_path = "/content/drive/MyDrive/Fluid Proj/New_Noise_Gaussian_80"
image_array = load_images_from_folder(folder_path)

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img.flatten())
    return np.array(images)

def compute_mean(images):
    return np.mean(images, axis=0)

def compute_fluctuation_matrix(images, mean_image):
    return images - mean_image

def perform_svd(fluctuation_matrix):
    U, S, Vt = np.linalg.svd(fluctuation_matrix, full_matrices=False)
    return U, S, Vt



images_folder = '/content/drive/MyDrive/Fluid Proj/New_Noise_Gaussian_80'
batch_size = 100
modes = 10

images = read_images(images_folder)

mean_image = compute_mean(images)

num_batches = len(images) // batch_size + 1
for batch_idx in range(num_batches):
    start_idx = batch_idx * batch_size
    end_idx = min((batch_idx + 1) * batch_size, len(images))
    batch_images = images[start_idx:end_idx]

    if len(batch_images) == 0:
        break

    fluctuation_matrix = compute_fluctuation_matrix(batch_images, mean_image)

    U, S, Vt = perform_svd(fluctuation_matrix)


print("Printing top 10 energy states modes completed!")

def reconstruct_images(U, S, Vt, modes):
    reconstructed_images  = U @ S @ Vt + compute_mean(images)
    return reconstructed_images

S_new = np.zeros((100,100))
np.fill_diagonal(S_new, S)
reconstructed_images = reconstruct_images(U, S_new, Vt, modes)

import numpy as np
import matplotlib.pyplot as plt

singular_values = S

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(singular_values) + 1), singular_values, marker='o', linestyle='-')
plt.title('Singular Values')
plt.xlabel('Mode')
plt.ylabel('Singular Value')
plt.grid(True)
plt.show()

cumulative_energy = np.cumsum(singular_values ** 2 / np.sum(singular_values ** 2))

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(cumulative_energy) + 1), cumulative_energy, marker='o', linestyle='-')
plt.title('Cumulative Energy Captured by Modes')
plt.xlabel('Number of Modes')
plt.ylabel('Cumulative Energy')
plt.grid(True)
plt.show()

top_modes_indices = np.argsort(singular_values)[::-1][:10]
top_modes_energy = singular_values

print("Top 10 energy states (modes):")
for mode, energy in zip(top_modes_indices, top_modes_energy):
    print(f"Mode {mode + 1}: Energy = {round(energy,4)}")

import matplotlib.pyplot as plt

# Plot the top 10 reconstructed images
plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(image_array[0].shape), cmap=None)
    plt.title(f"Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img)
    return images



def add_speckle_noise(image, magnitude):
    noise = magnitude * np.random.randn(*image.shape)
    noisy_image = image + image * noise
    noisy_image = np.clip(noisy_image, 0, 255).astype(np.uint8)
    return noisy_image

images_folder = '/content/drive/MyDrive/Fluid Proj/Imagestack2'
output_folder = '/content/drive/MyDrive/Fluid Proj/Noisy_Images_speckle'

original_images = read_images(images_folder)

noise_magnitudes = [0.2, 0.4, 0.6, 0.8]
noise_types = ['Speckle']

for noise_type in noise_types:
    for magnitude in noise_magnitudes:
        for idx, image in enumerate(original_images):
            if noise_type == 'Speckle':
                noisy_image = add_speckle_noise(image, magnitude)

            output_filename = f'{noise_type}_Noise_{int(magnitude*100)}_{idx+1}.png'
            cv2.imwrite(os.path.join(output_folder, output_filename), noisy_image)

print("Noise addition completed!")

from PIL import Image
import numpy as np
import os

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir(folder):
        img_path = os.path.join(folder, filename)
        if os.path.isfile(img_path):
            try:
                img = Image.open(img_path)
                img_gray = img.convert('L')
                img_array = np.array(img_gray)
                images.append(img_array)
            except:
                print(f"Failed to load image: {img_path}")
    return images

folder_path = "/content/drive/MyDrive/Fluid Proj/New_Noise_Spackle_20"
image_array = load_images_from_folder(folder_path)

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img.flatten())
    return np.array(images)

def compute_mean(images):
    return np.mean(images, axis=0)

def compute_fluctuation_matrix(images, mean_image):
    return images - mean_image

def perform_svd(fluctuation_matrix):
    U, S, Vt = np.linalg.svd(fluctuation_matrix, full_matrices=False)
    return U, S, Vt



images_folder = '/content/drive/MyDrive/Fluid Proj/New_Noise_Spackle_20'
batch_size = 100
modes = 10

images = read_images(images_folder)

mean_image = compute_mean(images)

num_batches = len(images) // batch_size + 1
for batch_idx in range(num_batches):
    start_idx = batch_idx * batch_size
    end_idx = min((batch_idx + 1) * batch_size, len(images))
    batch_images = images[start_idx:end_idx]

    if len(batch_images) == 0:
        break

    fluctuation_matrix = compute_fluctuation_matrix(batch_images, mean_image)

    U, S, Vt = perform_svd(fluctuation_matrix)


print("Printing top 10 energy states modes completed!")

def reconstruct_images(U, S, Vt, modes):
    reconstructed_images  = U @ S @ Vt + compute_mean(images)
    return reconstructed_images

S_new = np.zeros((100,100))
np.fill_diagonal(S_new, S)
reconstructed_images = reconstruct_images(U, S_new, Vt, modes)

import numpy as np
import matplotlib.pyplot as plt

singular_values = S

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(singular_values) + 1), singular_values, marker='o', linestyle='-')
plt.title('Singular Values')
plt.xlabel('Mode')
plt.ylabel('Singular Value')
plt.grid(True)
plt.show()

cumulative_energy = np.cumsum(singular_values ** 2 / np.sum(singular_values ** 2))

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(cumulative_energy) + 1), cumulative_energy, marker='o', linestyle='-')
plt.title('Cumulative Energy Captured by Modes')
plt.xlabel('Number of Modes')
plt.ylabel('Cumulative Energy')
plt.grid(True)
plt.show()

top_modes_indices = np.argsort(singular_values)[::-1][:10]
top_modes_energy = singular_values

print("Top 10 energy states (modes):")
for mode, energy in zip(top_modes_indices, top_modes_energy):
    print(f"Mode {mode + 1}: Energy = {round(energy,4)}")

import matplotlib.pyplot as plt

# Plot the top 10 reconstructed images
plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(image_array[0].shape), cmap=None)
    plt.title(f"Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()



from PIL import Image
import numpy as np
import os

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir(folder):
        img_path = os.path.join(folder, filename)
        if os.path.isfile(img_path):
            try:
                img = Image.open(img_path)
                img_gray = img.convert('L')
                img_array = np.array(img_gray)
                images.append(img_array)
            except:
                print(f"Failed to load image: {img_path}")
    return images

folder_path = "/content/drive/MyDrive/Fluid Proj/new_speckle_40"
image_array = load_images_from_folder(folder_path)

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img.flatten())
    return np.array(images)

def compute_mean(images):
    return np.mean(images, axis=0)

def compute_fluctuation_matrix(images, mean_image):
    return images - mean_image

def perform_svd(fluctuation_matrix):
    U, S, Vt = np.linalg.svd(fluctuation_matrix, full_matrices=False)
    return U, S, Vt



images_folder = '/content/drive/MyDrive/Fluid Proj/new_speckle_40'
batch_size = 100
modes = 10

images = read_images(images_folder)

mean_image = compute_mean(images)

num_batches = len(images) // batch_size + 1
for batch_idx in range(num_batches):
    start_idx = batch_idx * batch_size
    end_idx = min((batch_idx + 1) * batch_size, len(images))
    batch_images = images[start_idx:end_idx]

    if len(batch_images) == 0:
        break

    fluctuation_matrix = compute_fluctuation_matrix(batch_images, mean_image)

    U, S, Vt = perform_svd(fluctuation_matrix)


print("Printing top 10 energy states modes completed!")

def reconstruct_images(U, S, Vt, modes):
    reconstructed_images  = U @ S @ Vt + compute_mean(images)
    return reconstructed_images

S_new = np.zeros((100,100))
np.fill_diagonal(S_new, S)
reconstructed_images = reconstruct_images(U, S_new, Vt, modes)

import numpy as np
import matplotlib.pyplot as plt

singular_values = S

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(singular_values) + 1), singular_values, marker='o', linestyle='-')
plt.title('Singular Values')
plt.xlabel('Mode')
plt.ylabel('Singular Value')
plt.grid(True)
plt.show()

cumulative_energy = np.cumsum(singular_values ** 2 / np.sum(singular_values ** 2))

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(cumulative_energy) + 1), cumulative_energy, marker='o', linestyle='-')
plt.title('Cumulative Energy Captured by Modes')
plt.xlabel('Number of Modes')
plt.ylabel('Cumulative Energy')
plt.grid(True)
plt.show()

top_modes_indices = np.argsort(singular_values)[::-1][:10]
top_modes_energy = singular_values

print("Top 10 energy states (modes):")
for mode, energy in zip(top_modes_indices, top_modes_energy):
    print(f"Mode {mode + 1}: Energy = {round(energy,4)}")

import matplotlib.pyplot as plt

# Plot the top 10 reconstructed images
plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(image_array[0].shape), cmap=None)
    plt.title(f"Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()





from PIL import Image
import numpy as np
import os

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir(folder):
        img_path = os.path.join(folder, filename)
        if os.path.isfile(img_path):
            try:
                img = Image.open(img_path)
                img_gray = img.convert('L')
                img_array = np.array(img_gray)
                images.append(img_array)
            except:
                print(f"Failed to load image: {img_path}")
    return images

folder_path = "/content/drive/MyDrive/Fluid Proj/new_speckle_60"
image_array = load_images_from_folder(folder_path)

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img.flatten())
    return np.array(images)

def compute_mean(images):
    return np.mean(images, axis=0)

def compute_fluctuation_matrix(images, mean_image):
    return images - mean_image

def perform_svd(fluctuation_matrix):
    U, S, Vt = np.linalg.svd(fluctuation_matrix, full_matrices=False)
    return U, S, Vt



images_folder = '/content/drive/MyDrive/Fluid Proj/new_speckle_60'
batch_size = 100
modes = 10

images = read_images(images_folder)

mean_image = compute_mean(images)

num_batches = len(images) // batch_size + 1
for batch_idx in range(num_batches):
    start_idx = batch_idx * batch_size
    end_idx = min((batch_idx + 1) * batch_size, len(images))
    batch_images = images[start_idx:end_idx]

    if len(batch_images) == 0:
        break

    fluctuation_matrix = compute_fluctuation_matrix(batch_images, mean_image)

    U, S, Vt = perform_svd(fluctuation_matrix)


print("Printing top 10 energy states modes completed!")

def reconstruct_images(U, S, Vt, modes):
    reconstructed_images  = U @ S @ Vt + compute_mean(images)
    return reconstructed_images

S_new = np.zeros((100,100))
np.fill_diagonal(S_new, S)
reconstructed_images = reconstruct_images(U, S_new, Vt, modes)

import numpy as np
import matplotlib.pyplot as plt

singular_values = S

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(singular_values) + 1), singular_values, marker='o', linestyle='-')
plt.title('Singular Values')
plt.xlabel('Mode')
plt.ylabel('Singular Value')
plt.grid(True)
plt.show()

cumulative_energy = np.cumsum(singular_values ** 2 / np.sum(singular_values ** 2))

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(cumulative_energy) + 1), cumulative_energy, marker='o', linestyle='-')
plt.title('Cumulative Energy Captured by Modes')
plt.xlabel('Number of Modes')
plt.ylabel('Cumulative Energy')
plt.grid(True)
plt.show()

top_modes_indices = np.argsort(singular_values)[::-1][:10]
top_modes_energy = singular_values

print("Top 10 energy states (modes):")
for mode, energy in zip(top_modes_indices, top_modes_energy):
    print(f"Mode {mode + 1}: Energy = {round(energy,4)}")

import matplotlib.pyplot as plt

# Plot the top 10 reconstructed images
plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(image_array[0].shape), cmap=None)
    plt.title(f"Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

from PIL import Image
import numpy as np
import os

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir(folder):
        img_path = os.path.join(folder, filename)
        if os.path.isfile(img_path):
            try:
                img = Image.open(img_path)
                img_gray = img.convert('L')
                img_array = np.array(img_gray)
                images.append(img_array)
            except:
                print(f"Failed to load image: {img_path}")
    return images

folder_path = "/content/drive/MyDrive/Fluid Proj/new_speckle_80"
image_array = load_images_from_folder(folder_path)

import numpy as np
import cv2
import os

def read_images(folder):
    images = []
    for filename in sorted(os.listdir(folder)):
        img = cv2.imread(os.path.join(folder, filename), cv2.IMREAD_GRAYSCALE)
        if img is not None:
            images.append(img.flatten())
    return np.array(images)

def compute_mean(images):
    return np.mean(images, axis=0)

def compute_fluctuation_matrix(images, mean_image):
    return images - mean_image

def perform_svd(fluctuation_matrix):
    U, S, Vt = np.linalg.svd(fluctuation_matrix, full_matrices=False)
    return U, S, Vt



images_folder = '/content/drive/MyDrive/Fluid Proj/new_speckle_80'
batch_size = 100
modes = 10

images = read_images(images_folder)

mean_image = compute_mean(images)

num_batches = len(images) // batch_size + 1
for batch_idx in range(num_batches):
    start_idx = batch_idx * batch_size
    end_idx = min((batch_idx + 1) * batch_size, len(images))
    batch_images = images[start_idx:end_idx]

    if len(batch_images) == 0:
        break

    fluctuation_matrix = compute_fluctuation_matrix(batch_images, mean_image)

    U, S, Vt = perform_svd(fluctuation_matrix)

def reconstruct_images(U, S, Vt, modes):
    reconstructed_images  = U @ S @ Vt + compute_mean(images)
    return reconstructed_images

S_new = np.zeros((100,100))
    np.fill_diagonal(S_new, S)
    reconstructed_images = reconstruct_images(U, S_new, Vt, modes)

import numpy as np
import matplotlib.pyplot as plt

singular_values = S

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(singular_values) + 1), singular_values, marker='o', linestyle='-')
plt.title('Singular Values')
plt.xlabel('Mode')
plt.ylabel('Singular Value')
plt.grid(True)
plt.show()

cumulative_energy = np.cumsum(singular_values ** 2 / np.sum(singular_values ** 2))

plt.figure(figsize=(10, 6))
plt.plot(np.arange(1, len(cumulative_energy) + 1), cumulative_energy, marker='o', linestyle='-')
plt.title('Cumulative Energy Captured by Modes')
plt.xlabel('Number of Modes')
plt.ylabel('Cumulative Energy')
plt.grid(True)
plt.show()

top_modes_indices = np.argsort(singular_values)[::-1][:10]
top_modes_energy = singular_values

print("Top 10 energy states (modes):")
for mode, energy in zip(top_modes_indices, top_modes_energy):
    print(f"Mode {mode + 1}: Energy = {round(energy,4)}")

import matplotlib.pyplot as plt

# Plot the top 10 reconstructed images
plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(image_array[0].shape), cmap=None)
    plt.title(f"Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras import layers, models

def autoencoder(input_shape):
    inputs = layers.Input(shape=input_shape)
    x = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(inputs)
    x = layers.MaxPooling2D((2, 2), padding='same')(x)
    x = layers.Conv2DTranspose(32, (3, 3), activation='relu', padding='same')(x)
    x = layers.UpSampling2D((2, 2))(x)
    outputs = layers.Conv2D(1, (3, 3), activation='sigmoid', padding='same')(x)
    model = models.Model(inputs=inputs, outputs=outputs)
    return model

def load_images_from_folder(folder_path, target_size=(256, 256)):
    images = []
    for filename in os.listdir(folder_path):
        img_path = os.path.join(folder_path, filename)
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        img = cv2.resize(img, target_size)
        img = img.astype('float32') / 255.0
        img = img[..., np.newaxis]
        images.append(img)
    return np.array(images)

def denoise_images(model, noisy_images):
    denoised_images = []
    for noisy_image in noisy_images:
        denoised_image = model.predict(np.expand_dims(noisy_image, axis=0))
        denoised_images.append(denoised_image.squeeze())
    return denoised_images

input_folder = '/content/drive/MyDrive/Fluid Proj/New_Noise_Gaussian'

noisy_images = load_images_from_folder(input_folder)

input_shape = noisy_images[0].shape
model = autoencoder(input_shape)


denoised_images = denoise_images(model, noisy_images)

num_images = min(len(noisy_images), 4)
plt.figure(figsize=(15, 6))

for i in range(num_images):
    plt.subplot(2, num_images, i + 1)
    plt.imshow(noisy_images[i][:, :, 0], cmap=None)
    plt.title('Noisy')
    plt.axis('off')

    plt.subplot(2, num_images, num_images + i + 1)
    plt.imshow(denoised_images[i], cmap=None)
    plt.title('Denoised')
    plt.axis('off')

plt.subplots_adjust(wspace=0.4, hspace=0.4)
plt.show()

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras import layers, models

def autoencoder(input_shape):
    inputs = layers.Input(shape=input_shape)
    x = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(inputs)
    x = layers.MaxPooling2D((2, 2), padding='same')(x)
    x = layers.Conv2DTranspose(32, (3, 3), activation='relu', padding='same')(x)
    x = layers.UpSampling2D((2, 2))(x)
    outputs = layers.Conv2D(1, (3, 3), activation='sigmoid', padding='same')(x)
    model = models.Model(inputs=inputs, outputs=outputs)
    return model

def load_images_from_folder(folder_path, target_size=(256, 256)):
    images = []
    for filename in os.listdir(folder_path):
        img_path = os.path.join(folder_path, filename)
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        img = cv2.resize(img, target_size)
        img = img.astype('float32') / 255.0
        img = img[..., np.newaxis]
        images.append(img)
    return np.array(images)

def denoise_images(model, noisy_images):
    denoised_images = []
    for noisy_image in noisy_images:
        denoised_image = model.predict(np.expand_dims(noisy_image, axis=0))
        denoised_images.append(denoised_image.squeeze())
    return denoised_images

input_folder = '/content/drive/MyDrive/Fluid Proj/New_Noise_Spackle'

noisy_images = load_images_from_folder(input_folder)

input_shape = noisy_images[0].shape
model = autoencoder(input_shape)


denoised_images = denoise_images(model, noisy_images)

num_images = min(len(noisy_images), 4)
plt.figure(figsize=(15, 6))

for i in range(num_images):
    plt.subplot(2, num_images, i + 1)
    plt.imshow(noisy_images[i][:, :, 0], cmap=None)
    plt.title('Noisy')
    plt.axis('off')

    plt.subplot(2, num_images, num_images + i + 1)
    plt.imshow(denoised_images[i], cmap=None)
    plt.title('Denoised')
    plt.axis('off')

plt.subplots_adjust(wspace=0.4, hspace=0.4)
plt.show()